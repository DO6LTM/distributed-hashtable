ListNode {
	node left;
	node right;
	
	float hash_value; /* Hashwert von this */
	int[] r; /* Bitstring von hash_value */
	int R_LENGTH = 64; /* Länge von r */
	
	/* Konstruktor */
	init() {
		/* Hashen, Bitrepräs. */
		hash_value = g(id(this));
		
		floatToBitstring(hash_value, R_LENGTH, r);
	}
	
	/* Hashwert F als Bitstring der Länge L in A schreiben */
	floatToBitstring(float F, int L, int[] A) {
		A <<<<;
		float tmp = F;
		int i;
		float res;
		for (i = 0; i < L; i++) {
			res = tmp * 2.0;
			if (res > 1) {
				A >> 1;
				tmp = res - 1.0;
			}
			else if (res < 1) {
				A >> 0;
				tmp = res;
			}
		}
		while (length(A) < L) {
			A >> 0;
		}
	}
	
	/* Schreibt die ersten I Bits von r(V) in A */
	prefix(int I, node V, int[] A) {
		int[] tmp;
		floatToBitstring(g(id(V)), R_LENGTH, tmp);
		A <<<<;
		int i;
		for (i = 0; i < I; i++) {
			A >> tmp[i];
		}
	}
	
	/* Gibt den nächsten Nachfolger von V zurück mit prefix_i(V)*B */
	succ node(int I, node V, int B, int[] A) {
		int[] pref;
		prefix(I, V, pref);
		pref >> B;
		/* TODO Nachfolger suchen */
	}
	
	/* Hashfunktion g, bildet I auf [0,1) ab */
	g float(int I) {
		float i = hash(I);
		i = i / MAX_INTEGER;
		i = (i + 1) / 2;
		return i;
	}
	
	entry(node C) {
		linearize(C);
	}

	timeout() {
		/* 1a TODO linearisiere */
		/* 1b TODO überbrücke */
		if (left != null & g(id(left)) < hash_value) {
			left -> linearize(this);
		}
		else{
			this -> linearize(left);
			left = null;
		}
		if (right != null & g(id(right)) > hash_value) {
			right -> linearize(this);
		}
		else{
			this -> linearize(right);
			right = null;
		}
	}

	linearize(node V) {
		/* 2 TODO linearisiere */
		if (g(id(V)) < hash_value) {
			if (left == null) {
				left = V;
			}
			else {
				if (g(id(left)) < g(id(V))) {
					V -> linearize(left);
					left = V;
				}
				else {
					left -> linearize(V);
				}
			}
		}
		else if(g(id(V)) > hash_value) {
			if (right == null) {
				right = V;
			}
			else {
				if(g(id(right)) > g(id(V))) {
					V -> linearize(right);
					right = V;
				}
				else{
					right -> linearize(V);
				}
			}
		}
	}
} 