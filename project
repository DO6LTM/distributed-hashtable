/*
	Methoden, die mit einem _ beginnen, werden als Setter-Funktionen von anderen Knoten aufgerufen.
*/
ListNode {
	node[] left;
	node[] right;
	
	float hash_value; /* Hashwert von this */
	float hash_value_bitstring; /* Hashwert von this für die Erstellung des Bitstrings */
	int[][] r; /* Bitstring von hash_value */
	float[][] range; /* Für jeden Level i speichert range[i][0] linke Grenze und range[i][1] rechte Grenze */
	node[][] n green; /* Für jeden Level i speichert n[i][*] die Nachbarknoten */
	int [] n_length; /* Speichert Länge des Arrays n[i] */
	int R_LENGTH = 64; /* Länge von r */
	
	node[] succs hidden; /* Zum temporären Speichern von succ und pred */
	node[] preds hidden;
	
	/* Konstruktor */
	init() {
		/* Hashen, Bitrepräs. */
		hash_value = h(id(this));
		hash_value_bitstring = g(id(this));
		
		floatToBitstringCache(hash_value_bitstring, R_LENGTH, r, id(this));
	}
	
	/* Hashwert F als Bitstring der Länge L in A an Index I schreiben */
	floatToBitstringCache(float F, int L, int[][] A, int I) {
		float tmp = F;
		int i;
		float res;
		for (i = 0; i < L; i++) {
			res = tmp * 2.0;
			if (res >= 1) {
				A[I][i] = 1;
				tmp = res - 1.0;
			}
			else if (res < 1) {
				A[I][i] = 0;
				tmp = res;
			}
		}
	}
	
	/* Hashwert F als Bitstring der Länge L in A schreiben */
	floatToBitstring(float F, int L, int[] A) {
		A <<<<;
		float tmp = F;
		int i;
		float res;
		for (i = 0; i < L; i++) {
			res = tmp * 2.0;
			if (res > 1) {
				A >> 1;
				tmp = res - 1.0;
			}
			else if (res < 1) {
				A >> 0;
				tmp = res;
			}
		}
		while (length(A) < L) {
			A >> 0;
		}
	}
	
	/* Schreibt die ersten I Bits von r(V) in A */
	prefix(int I, node V, int[] A) {
		int[] tmp;
		floatToBitstring(g(id(V)), R_LENGTH, tmp);
		A <<<<;
		int i;
		for (i = 0; i < I; i++) {
			A >> tmp[i];
		}
	}
	
	/* Speichert den nächsten Vorgänger von V in preds[B] mit prefix_i(V)*B */
	pred(int I, node V, int B) {
		int[] pref;
		prefix(I, V, pref);
		pref >> B;
		if(left[0] != null) {
			left[0] -> add_to_pred(this, pref, B, I);
		}
	}
	
	/* Fügt this zu V.preds hinzu, wenn P übereinstimmt 
	   P=(pref*B); |P|=I+1 */
	add_to_pred(node V, int[] P, int B, int I) {
		bool mismatch = false;
		int i;
		for (i = 0; i < length(P); i++) {
			if (P[i] != r[id(this)][i]) {
				mismatch = true;
				break;
			}
		}
		if (mismatch == false) {
			P <<;
			V -> _add_to_pred(this, B, I, P);
		}
		else {
			if (left[0] != null) {
				left[0] -> add_to_pred(V, P, B, I);
			}
			else {
				P <<;
				V -> _add_to_pred(V, B, I, P);
			}
		}
	}
	
	/* Fügt V an Index I zu preds hinzu*/
	_add_to_pred(node V, int B, int I, int[] P) {
		preds[B] = V;
		if (length(preds) == 2 & length(succs) == 2) {
			set_range(I, P);
		}
	}
	
	/* Speichert den nächsten Nachfolger von V in succs[B] mit prefix_i(V)*B */
	succ(int I, node V, int B) {
		int[] pref;
		prefix(I, V, pref);
		pref >> B;
		if(right[0] != null) {
			right[0] -> add_to_succ(this, pref, B, I);
		}
	}
	
	/* Fügt this zu succs hinzu, wenn P übereinstimmt */
	add_to_succ(node V, int[] P, int B, int I) {
		bool mismatch = false;
		int i;
		for (i = 0; i < length(P); i++) {
			if (P[i] != r[id(this)][i]) {
				mismatch = true;
				break;
			}
		}
		if (mismatch == false) {
			P <<;
			V -> _add_to_succ(this, B, I, P);
		}
		else {
			if (right[0] != null) {
				right[0] -> add_to_succ(V, P, B, I);
			}
			else {
				P <<;
				V -> _add_to_succ(V, B, I, P);
			} 
		}
	}
	
	/* Fügt V an Index I zu succs hinzu*/
	_add_to_succ(node V, int B, int I, int[] P) {
		succs[B] = V;
		if (length(preds) == 2 & length(succs) == 2) {
			set_range(I, P);
		}
	}
	
	/* Aktualisiert die range für einen Level I */
	update_range(int I) {
		preds <<<<;
		succs <<<<;
		
		range[I][0] = 0;
		range[I][1] = 1;
		
		pred(I, this, 0);
		pred(I, this, 1);
		
		succ(I, this, 0);
		succ(I, this, 1);
	}
	
	set_range(int I, int[] P) {
		if (h(id(preds[0])) == hash_value | h(id(preds[1])) == hash_value) {
			range[I][0] = 0.0;
		}
		else {
			if (h(id(preds[0])) < h(id(preds[1]))) {
				range[I][0] = h(id(preds[0]));
			}
			else {
				range[I][0] = h(id(preds[1]));
			}
		}
		
		if (h(id(succs[0])) == hash_value | h(id(succs[1])) == hash_value) {
			range[I][1] = 1.0;
		}
		else {
			if (h(id(succs[0])) > h(id(succs[1]))) {
				range[I][1] = h(id(succs[0]));
			}
			else {
				range[I][1] = h(id(succs[1]));
			}
		}
		update_n(I, P);
	}
	
	/* Aktualisiert n für einen Level I */
	update_n(int I, int[] P) {
		int i;
		for (i = 0; i < n_length[I]; i++) {
			n[I][i] = null;
		}
		n_length[I] = 0;
		
		float l = range[I][0];
		float r = range[I][1];
		add_to_n_for_left(I, this, l, r, P);
		add_to_n_for_right(I, this, l, r, P);
	}
	
	/* Anfrage, ob Knoten in n von V eingefügt werden soll, wenn g(id(this)) in range[I]=[L,R] liegt und Präfix P übereinstimmt, für alle linken Knoten */
	add_to_n_for_left(int I, node V, float L, float R, int[] P) {
		float key = h(id(this));
		if (V != this) {
			bool mismatch = false;
			int i;
			for (i = 0; i < length(P); i++) {
				if (P[i] != r[id(this)][i]) {
					mismatch = true;
					break;
				}
			}
			if (L <= key & key <= R & mismatch == false) {			
				V -> _add_to_n(I, this);
			}
		}
		if (left[0] != null & L <= key) {
			left[0] -> add_to_n_for_left(I, V, L, R, P);
		}
	}
	
	/* Anfrage, ob Knoten in n von V eingefügt werden soll, wenn g(id(this)) in range[I]=[L,R] liegt und Präfix P übereinstimmt, für alle rechten Knoten */
	add_to_n_for_right(int I, node V, float L, float R, int[] P) {
		float key = h(id(this));
		if (V != this) {
			bool mismatch = false;
			int i;
			for (i = 0; i < length(P); i++) {
				if (P[i] != r[id(this)][i]) {
					mismatch = true;
					break;
				}
			}
			if (L <= key & key <= R & mismatch == false) {
				V -> _add_to_n(I, this);
			}
		}
		if (right[0] != null & key <= R) {
			right[0] -> add_to_n_for_right(I, V, L, R, P);
		}
	}
	
	/* Fügt Knoten V in n ein für Level I ein */
	_add_to_n(int I, node V) {
		int i;
		for (i = 0; i < n_length[I]; i++) {
			if (n[I][i] == V) {
				return;
			}
		}
		n[I][n_length[I]] = V;
		n_length[I] = n_length[I] + 1;
	}
	
	/* Hashfunktion h, bildet I auf [0,1) ab */
	h float(int I) {
		float i = hash(I);
		i = i / MAX_INTEGER;
		i = (i + 1) / 2;
		return i;
	}
	
	/* Hashfunktion g, bildet I auf [0,1) ab. Wird genutzt um Bitstrings zu generieren. */
	g float(int I) {
		float i = hash1(I);
		i = i / MAX_INTEGER;
		i = (i + 1) / 2;
		return i;
	}
	
	entry(node C) {
		linearize(C);
	}

	timeout() {
		/* 1a TODO linearisiere */
		if (left[0] != null & h(id(left[0])) < hash_value) {
			left[0] -> linearize(this);
		}
		else{
			this -> linearize(left[0]);
			left[0] = null;
		}
		if (right[0] != null & h(id(right[0])) > hash_value) {
			right[0] -> linearize(this);
		}
		else{
			this -> linearize(right[0]);
			right[0] = null;
		}
		/* 1b TODO überbrücke */
	}

	linearize(node V) {	
		if (h(id(V)) < hash_value) {
			if (left[0] == null) {
				left[0] = V;
			}
			else {
				if (h(id(left[0])) < h(id(V))) {
					V -> linearize(left[0]);
					left[0] = V;
				}
				else {
					left[0] -> linearize(V);
				}
			}
		}
		else if(h(id(V)) > hash_value) {
			if (right[0] == null) {
				right[0] = V;
			}
			else {
				if(h(id(right[0])) > h(id(V))) {
					V -> linearize(right[0]);
					right[0] = V;
				}
				else{
					right[0] -> linearize(V);
				}
			}
		}
	}
} 