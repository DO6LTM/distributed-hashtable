/*
	Methoden, die mit einem _ beginnen, werden als Setter-Funktionen von anderen Knoten aufgerufen.
*/
ListNode {
	node[] left;
	node[] right;
	
	float hash_value; /* Hashwert von this */
	int[][] r; /* Bitstring von hash_value */
	float[][] range; /* Für jeden Level i speichert range[i][0] linke Grenze und range[i][1] rechte Grenze */
	node[][] n; /* Für jeden Level i speichert n[i][*] die Nachbarknoten */
	int [] n_length; /* Speichert Länge des Arrays n[i] */
	int R_LENGTH = 64; /* Länge von r */
	
	node[] succs; /* Zum temporären Speichern von succ und pred */
	node[] preds;
	
	/* Konstruktor */
	init() {
		/* Hashen, Bitrepräs. */
		hash_value = g(id(this));
		
		floatToBitstringCache(hash_value, R_LENGTH, r, id(this));
	}
	
	/* Hashwert F als Bitstring der Länge L in A an Index I schreiben */
	floatToBitstringCache(float F, int L, int[][] A, int I) {
		float tmp = F;
		int i;
		float res;
		for (i = 0; i < L; i++) {
			res = tmp * 2.0;
			if (res >= 1) {
				A[I][i] = 1;
				tmp = res - 1.0;
			}
			else if (res < 1) {
				A[I][i] = 0;
				tmp = res;
			}
		}
	}
	
	/* Hashwert F als Bitstring der Länge L in A schreiben */
	floatToBitstring(float F, int L, int[] A) {
		A <<<<;
		float tmp = F;
		int i;
		float res;
		for (i = 0; i < L; i++) {
			res = tmp * 2.0;
			if (res > 1) {
				A >> 1;
				tmp = res - 1.0;
			}
			else if (res < 1) {
				A >> 0;
				tmp = res;
			}
		}
		while (length(A) < L) {
			A >> 0;
		}
	}
	
	/* Schreibt die ersten I Bits von r(V) in A */
	prefix(int I, node V, int[] A) {
		int[] tmp;
		floatToBitstring(g(id(V)), R_LENGTH, tmp);
		A <<<<;
		int i;
		for (i = 0; i < I; i++) {
			A >> tmp[i];
		}
	}
	
	/* Speichert den nächsten Vorgänger von V in preds[B] mit prefix_i(V)*B */
	pred(int I, node V, int B) {
		int[] pref;
		prefix(I, V, pref);
		pref >> B;
		if(left[0] != null) {
			left[0] -> add_to_pred(this, pref, B, I);
		}
	}
	
	/* Fügt this zu preds hinzu, wenn P übereinstimmt */
	add_to_pred(node V, int[] P, int B, int I) {
		bool mismatch = false;
		int i;
		for (i = 0; i < length(P); i++) {
			if (P[i] != r[id(this)][i]) {
				mismatch = true;
				break;
			}
		}
		if (mismatch == false) {
			V -> _add_to_pred(this, B, I);
			P <<<<;
		}
		else {
			if (left[0] != null) {
				left[0] -> add_to_pred(V, P, B, I);
			}
			else {
				V -> _add_to_pred(V, B, I);
				P <<<<;
			}
		}
	}
	
	/* Fügt V an Index I zu preds hinzu*/
	_add_to_pred(node V, int B, int I) {
		preds[B] = V;
		if (length(preds) == 2 & length(succs) == 2) {
			set_range(I);
		}
	}
	
	/* Speichert den nächsten Nachfolger von V in succs[B] mit prefix_i(V)*B */
	succ(int I, node V, int B) {
		int[] pref;
		prefix(I, V, pref);
		pref >> B;
		if(right[0] != null) {
			right[0] -> add_to_succ(this, pref, B, I);
		}
	}
	
	/* Fügt this zu succs hinzu, wenn P übereinstimmt */
	add_to_succ(node V, int[] P, int B, int I) {
		bool mismatch = false;
		int i;
		for (i = 0; i < length(P); i++) {
			if (P[i] != r[id(this)][i]) {
				mismatch = true;
				break;
			}
		}
		if (mismatch == false) {
			V -> _add_to_succ(this, B, I);
			P <<<<;
		}
		else {
			if (right[0] != null) {
				right[0] -> add_to_succ(V, P, B, I);
			}
			else {
				V -> _add_to_succ(V, B, I);
				P <<<<;
			} 
		}
	}
	
	/* Fügt V an Index I zu succs hinzu*/
	_add_to_succ(node V, int B, int I) {
		succs[B] = V;
		if (length(preds) == 2 & length(succs) == 2) {
			set_range(I);
		}
	}
	
	/* Aktualisiert die range für einen Level I */
	update_range(int I) {
		range[I][0] = 0;
		range[I][1] = 1;
		
		pred(I, this, 0);
		pred(I, this, 1);
		
		succ(I, this, 0);
		succ(I, this, 1);
	}
	
	set_range(int I) {
		if (g(id(preds[0])) == hash_value | g(id(preds[1])) == hash_value) {
			range[I][0] = 0.0;
		}
		else {
			if (g(id(preds[0])) < g(id(preds[1]))) {
				range[I][0] = g(id(preds[0]));
			}
			else {
				range[I][0] = g(id(preds[1]));
			}
		}
		
		if (g(id(succs[0])) == hash_value | g(id(succs[1])) == hash_value) {
			range[I][1] = 1.0;
		}
		else {
			if (g(id(succs[0])) > g(id(succs[1]))) {
				range[I][1] = g(id(succs[0]));
			}
			else {
				range[I][1] = g(id(succs[1]));
			}
		}
		succs <<<<;
		preds <<<<;
		update_n(I);
	}
	
	/* Aktualisiert n für einen Level I */
	update_n(int I) {
		float l = range[I][0];
		float r = range[I][1];
		add_to_n_for_left(I, this, l, r);
		add_to_n_for_right(I, this, l, r);
	}
	
	/* Anfrage, ob Knoten in n von V eingefügt werden soll, wenn g(id(this)) in range[I] liegt für alle linken Knoten */
	add_to_n_for_left(int I, node V, float L, float R) {
		if (V != this) {
			float key = g(id(this));
			if (L <= key & key <= R) {
				V -> _add_to_n(I, this);
			}
		}
		if (left[0] != null) {
			left[0] -> add_to_n_for_left(I, V, L, R);
		}
	}
	
	/* Anfrage, ob Knoten in n von V eingefügt werden soll, wenn g(id(this)) in range[I] liegt für alle rechten Knoten */
	add_to_n_for_right(int I, node V, float L, float R) {
		if (V != this) {
			float key = g(id(this));
			if (L <= key & key <= R) {
				V -> _add_to_n(I, this);
			}
		}
		if (right[0] != null) {
			right[0] -> add_to_n_for_right(I, V, L, R);
		}
	}
	
	/* Fügt Knoten V in n ein für Level I ein */
	_add_to_n(int I, node V) {
		n[I][n_length[I]] = V;
		n_length[I] = n_length[I] + 1;
	}
	
	/* Hashfunktion g, bildet I auf [0,1) ab */
	g float(int I) {
		float i = hash(I);
		i = i / MAX_INTEGER;
		i = (i + 1) / 2;
		return i;
	}
	
	entry(node C) {
		linearize(C);
	}

	timeout() {
		/* 1a TODO linearisiere */
		if (left[0] != null & g(id(left[0])) < hash_value) {
			left[0] -> linearize(this);
		}
		else{
			this -> linearize(left[0]);
			left[0] = null;
		}
		if (right[0] != null & g(id(right[0])) > hash_value) {
			right[0] -> linearize(this);
		}
		else{
			this -> linearize(right[0]);
			right[0] = null;
		}
		/* 1b TODO überbrücke */
	}

	linearize(node V) {	
		if (g(id(V)) < hash_value) {
			if (left[0] == null) {
				left[0] = V;
			}
			else {
				if (g(id(left[0])) < g(id(V))) {
					V -> linearize(left[0]);
					left[0] = V;
				}
				else {
					left[0] -> linearize(V);
				}
			}
		}
		else if(g(id(V)) > hash_value) {
			if (right[0] == null) {
				right[0] = V;
			}
			else {
				if(g(id(right[0])) > g(id(V))) {
					V -> linearize(right[0]);
					right[0] = V;
				}
				else{
					right[0] -> linearize(V);
				}
			}
		}
	}
} 