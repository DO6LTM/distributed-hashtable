ListNode {
	node left;
	node right;
	
	float hash_value;
	int[] r;
	int R_LENGTH = 64;

	/* Konstruktor */
	init() {
		/* Hashen, Bitrepräs. */
		hash_value = g(this);
		
		/* Hashwert als Bitstring abspeichern */
		float tmp = hash_value;
		int i;
		float res;
		for (i = 0; i < R_LENGTH; i++) {
			res = tmp * 2.0;
			print(tmp);
			if (res > 1) {
				r >> 1;
				tmp = res - 1.0;
			}
			else if (res < 1) {
				r >> 0;
				tmp = res;
			}
		}
		while (length(r) < R_LENGTH) {
			r >> 0;
		}
	}
	
	/* Hashfunktion g, bildet node I auf [0,1) ab */
	g float(node I) {
		float i = hash(I);
		i = i / MAX_INTEGER;
		return i;
	}

	entry(node C) {
		linearize(C);
	}

	timeout() {
		/* 1a TODO linearisiere */
		/* 1b TODO überbrücke */
		if (left != null & id(left) < id(this)) {
			left -> linearize(this);
		}
		else{
			this -> linearize(left);
			left = null;
		}
		if (right != null & id(right)>id(this)) {
			right -> linearize(this);
		}
		else{
			this -> linearize(right);
			right = null;
		}
	}

	linearize(node V) {
		/* 2 TODO linearisiere */
		if (id(V)<id(this)) {
			if (left == null) {
				left = V;
			}
			else {
				if (id(left) < id(V)) {
					V -> linearize(left);
					left = V;
				}
				else {
					left -> linearize(V);
				}
			}
		}
		else if(id(V) > id(this)) {
			if (right == null) {
				right = V;
			}
			else {
				if(id(right) > id(V)) {
					V -> linearize(right);
					right = V;
				}
				else{
					right -> linearize(V);
				}
			}
			
		}
	}
} 
