SkipNode {
	float identifier; /* Hashwert von id(this) */
	string rs; /* pseudo-random Bitstring */
	int RS_LENGTH = 32; /* Länge des Bitstrings */
	node[] nh; /* Nachbarschaft von this */
	float[] nh_identifier;
	string[] nh_rs;

	/* Konstruktor */
	init() {
		identifier = h(id(this));
		rs = getBitstring(h1(id(this)));
	}
	
	/* Wird beim Initialisieren des Knotens aufgerufen */
	entry(node W) {
		W -> build(this);
	}
	
	/* Periodisches Timeout */
	timeout() {
		checkNeighbourhood();
		introduceNode();
		linearizeNeighbours();
		introduceClosestNeighbours();
	}
	
	/* Berechnet einen Bitstring der Länge RS_LENGTH anhand des Eingabewertes H */
	getBitstring string(float H) {
		string bitstring = "";
		int i;
		for (i = 0; i < RS_LENGTH; i++) {
			H = H * 2.0;
			if (H > 1) {
				bitstring = bitstring + 1;
				H = H - 1.0;
			}
			else if (H < 1) {
				bitstring = bitstring + 0;
			}
			else {
				bitstring = bitstring + 0;
				H = H / 2.0;
			}
		}
		return bitstring;
	}
	
	/* Gibt den Prefix der Länge I von V zurück */
	prefix string(string V, int I) {
		return sub_str(V, 0, I);
	}
	
	/* Ermittelt den größten gemeinsamen Prefix von V und W */
	commonPrefix int(string V, string W) {
		int i;
		for (i = RS_LENGTH; i > 0; i--) {
			if (prefix(V, i) == prefix(W, i)) {
				return i;
			}
		}
		return 0;
	}
	
	/* Ermittelt das aktuelle Level */
	level int() {
		int max = 0;
		for (node w : nh) {
			if (w != null & w != this) {
				int tmp = commonPrefix(rs, nh_rs[id(w)]);
				if (tmp > max) {
					max = tmp;
				}
			}
		}
		return max;
	}

	/* Hashfunktion h, bildet I auf [0,1) ab */
	h float(int I) {
		float i = hash(I);
		i = i / MAX_INTEGER;
		i = (i + 1) / 2;
		return i;
	}
	
	/* Hashfunktion h1, bildet I auf [0,1) ab. Wird genutzt um Bitstrings zu generieren. */
	h1 float(int I) {
		float i = hash1(I);
		i = i / MAX_INTEGER;
		i = (i + 1) / 2;
		return i;
	}
	
	/* Sendet build-Anfragen an alle Nachbarknoten */
	introduceNode() {
		for (node w : nh) {
			if (w != null) {
				w -> build(this);
			}
		}
	}
	
	/* Aktualisiert die Nachbarschaft; Entfernt ggf. w und delegiert an Knoten x mit größter Prefixübereinstimmung */
	checkNeighbourhood() {
		for (node w : nh) {
			if (w != null & w != this) {
				if (checkNode(w) == false) {
					nh[id(w)] = null;
					int argmax = 0;
					node max;
					for (node x : nh) {
						if (x != null) {
							int tmp = commonPrefix(nh_rs[id(w)], nh_rs[id(x)]);
							if (argmax <= tmp) {
								argmax = tmp;
								max = x;
							}
						}
					}
					nh_identifier[id(w)] = NaN;
					nh_rs[id(w)] = "";
					max -> build(w);
				}
			}
		}
	}
	
	/* Fügt X in nh ein */
	build(node X) {
		if (X == this | X == null) {
			return;
		}
		if (nh[id(X)] != null) {
			checkNeighbourhood();
		}
		else {
			nh[id(X)] = X;
			nh_identifier[id(X)] = h(id(X));
			nh_rs[id(X)] = getBitstring(h1(id(X)));
			if (checkNode(X) == true) {
				checkNeighbourhood();
			}
			else {
				nh[id(X)] = null;
				int argmax = 0;
				node max;
				for (node w : nh) {
					if (w != null) {
						int tmp = commonPrefix(nh_rs[id(X)], nh_rs[id(w)]);
						if (argmax <= tmp) {
							argmax = tmp;
							max = w;
						}
					}
				}
				nh_identifier[id(X)] = NaN;
				nh_rs[id(X)] = "";
				max -> build(X);
			}
		}
	}
	
	/* Prüft, ob ein Knoten W in der Range von this für eine Level i liegt */
	checkNode bool(node W) {
		bool needed = false;
		int i;
		for (i = 0; i <= level(); i++) {
			if (prefix(rs, i) == prefix(nh_rs[id(W)], i)
				& (predRange(i) == null | nh_identifier[id(W)] >= nh_identifier[id(predRange(i))]) 
				& (succRange(i) == null | nh_identifier[id(W)] <= nh_identifier[id(succRange(i))])) {
				needed = true;
				break;
			}
		}
		return needed;
	}
	
	/* Ermittelt den größten Vorgänger für Level I mit prefix * B */
	predRangeB node(int I, string B) {
		node<> preds;
		predecessors(I, preds);
		if (length(preds) < 1) {
			return null;
		}
		else {
			node argmax = null;
			float max = 0.0;
			int i;
			for (i = 0; i < length(preds); i++) {
				if (prefix(nh_rs[id(preds[i])], I + 1) == prefix(rs, I) + B & preds[i] != this & nh_identifier[id(preds[i])] >= max) {
					argmax = preds[i];
					max = nh_identifier[id(preds[i])];
				}
			}
			return argmax;
		}
	}
	
		
	/* Ermittelt den Vorgänger für Range von Level I */
	predRange node(int I) {
		node pred0 = predRangeB(I, "0");
		node pred1 = predRangeB(I, "1");

		if (pred0 == null | pred1 == null) {
			return null;
		}
		
		if (nh_identifier[id(pred0)] < nh_identifier[id(pred1)]) {
			return pred0;
		}
		else {
			return pred1;
		}
	}
	
	/* Ermittelt den kleinsten Nachfolger für Level I mit prefix * B */
	succRangeB node(int I, string B) {
		node<> succs;
		successors(I, succs);
		if (length(succs) < 1) {
			return null;
		}
		else {
			node argmin = null;
			float min = 1.0;
			int i;
			for (i = 0; i < length(succs); i++) {
				if (prefix(nh_rs[id(succs[i])], I + 1) == prefix(rs, I) + B & succs[i] != this & nh_identifier[id(succs[i])] <= min) {
					argmin = succs[i];
					min = nh_identifier[id(succs[i])];
				}
			}
			return argmin;
		}
	}
	
	/* Ermittelt den Nachfolger für Range von Level I */
	succRange node(int I) {
		node succ0 = succRangeB(I, "0");
		node succ1 = succRangeB(I, "1");

		if (succ0 == null | succ1 == null) {
			return null;
		}
		
		if (nh_identifier[id(succ0)] > nh_identifier[id(succ1)]) {
			return succ0;
		}
		else {
			return succ1;
		}
	}
	
	/* Stellt den Nachbarknoten die direkt Vorgänger und Nachfolger für jedes Level vor */
	introduceClosestNeighbours() {
		int i;
		node<> preds;
		node pred;
		node<> succs;
		node succ;
		for (i = 0; i <= level(); i++) {
			successors(i, succs);
			pred = closestPred(i);
			if (pred != null) {
				for (node w : succs) {
					w -> build(pred);
				}
			}
			succs <<<<;
			pred = null;

			predecessors(i, preds);
			succ = closestSucc(i);
			if (succ != null) {
				for (node w : preds) {
					w -> build(succ);
				}
			}
			preds <<<<;
			succ = null;
		}
	}
	
	/* Linearisiere Nachbarknoten */
	linearizeNeighbours() {
		int i;
		for (i = 0; i <= level(); i++) {
			node[] preds;
			predecessors(i, preds);
			sort(preds);
			int j;
			for (j = 0; j < length(preds) - 1; j++) {
				node to = preds[j];
				node m = preds[j+1];
				to -> build(m);
			}
			node last = preds[length(preds) - 1];
			last -> build(this);
			preds <<<<;
			
			node[] succs;
			successors(i, succs);
			sort(succs);
			for (j = length(succs) - 1; j > 0; j--) {
				node to = succs[j];
				node m = succs[j-1];
				to -> build(m);
			}
			node first = succs[0];
			first -> build(this);
			succs <<<<;
		}
	}
	
	/* Funktion zum Quicksort aufrufen */
	sort(node[] A) {
		quicksort(0, length(A)-1, A);
	}
	
	/* Quicksort aufruf mit l=0 und r=length(A[I])-1 */
	quicksort(int L, int R, node[] A) {
		if (L < R) {
			int m = teile(L, R, A);
			quicksort(L, m - 1, A);
			quicksort(m + 1, R, A);
		}
	}
	
	/* Hilfsfunktion für quicksort */
	teile int(int L, int R, node[] A) {
		int i = L;
		int j = R - 1;
		float pivot = nh_identifier[id(A[R])];
		
		while (i < j) {
			while (i < j & nh_identifier[id(A[i])] <= pivot) {
				i = i + 1;
			}
			
			while (j > i & nh_identifier[id(A[j])] > pivot) {
				j = j - 1;
			}
			
			if (nh_identifier[id(A[i])] > nh_identifier[id(A[j])]) {
				node tmp = A[i];
				A[i] = A[j];
				A[j] = tmp;
			}
		}
		
		if (nh_identifier[id(A[i])] > pivot) {
			node tmp = A[i];
			A[i] = A[R];
			A[R] = tmp;
		}
		else {
			i = R;
		}
		return i;
	}
	
	/* Filtert alle Nachbarknoten für ein Level I in eine Liste C */
	neighbours(int I, node<> C) {
		C <<<<;
		for (node u : nh) {
			if (u != null) {
				/*if (commonPrefix(rs, nh_rs[id(u)]) == I) { /* TODO vielleicht >= */
				if (prefix(rs, I) == prefix(nh_rs[id(u)], I)) {
					C >> u;
				}
			}
		}
	}
	
	/* Filtert alle Vorgänger der Nachbarknoten für ein Level I in eine Liste A */
	predecessors(int I, node<> B) {
		B <<<<;
		node<> n;
		neighbours(I, n);
		for (node u : n) {
			if (u != null & u != this) {
				if (nh_identifier[id(u)] < identifier) {
					B >> u;
				}
			}
		}

	}
	
	/* Gibt den nähesten Vorgänger für ein Level I zurück */
	closestPred node(int I) {
		node<> preds;
		preds <<<<;
		predecessors(I, preds);
		node argmax;
		float max = 0.0;
		for (node u : preds) {
			if (nh_identifier[id(u)] > max) {
				argmax = u;
				max = nh_identifier[id(u)];
			}
		}
		preds <<<<;
		return argmax;
	}
	
	/* Filtert alle Nachfolger der Nachbarknoten für ein Level I in eine Liste A */
	successors(int I, node<> A) {
		A <<<<;
		node<> n;
		neighbours(I, n);
		for (node u : n) {
			if (u != null & u != this) {
				if (nh_identifier[id(u)] > identifier) {
					A >> u;
				}
			}
		}
	}
	
	/* Gibt den nähesten Nachfolger für ein Level I zurück */
	closestSucc node(int I) {
		node<> succs;
		succs <<<<;
		successors(I, succs);
		node argmin;
		float min = 1.0;
		for (node u : succs) {
			if (nh_identifier[id(u)] < min) {
				argmin = u;
				min = nh_identifier[id(u)];
			}
		}
		succs <<<<;
		return argmin;
	}
	
	/* Sendet eine Anfrage zum Verlassen des Netzwerks */
	leave() {
		for (node w : nh) {
			if (w != null) {
				w -> remove(this);
			}
		}
		nh <<<<;
		nh_identifier <<<<;
		nh_rs <<<<;
	}
	
	/* Entfernt einen Knoten X aus nh */
	remove(node X) {
		if (nh[id(X)] != null) {
			nh[id(X)] = null;
			nh_identifier[id(X)] = NaN;
			nh_rs[id(X)] = "";
		}
	}
	
	/* Stelle lookup-Anfrage an Knoten X */
	lookup(node X) {
		if (id(this) == id(X)) {
			print("Knoten " + id(X) + " gefunden!");
		}
		else {
			string rs_x = getBitstring(h1(id(X)));
			int len;
			if (level() < commonPrefix(rs, rs_x)) {
				len = level();
			}
			else {
				len = commonPrefix(rs, rs_x);
			}
			node w = predRangeB(len, sub_str(rs_x,len,len+1));
			if (w == null) {
				w = succRangeB(len, sub_str(rs_x,len,len+1));
			}
			w -> lookup(X);
		}
	}
}