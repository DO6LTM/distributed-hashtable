SkipNode {
	float identifier; /* Hashwert von id(this) */
	string rs; /* pseudo-random Bitstring */
	int RS_LENGTH = 32; /* Länge des Bitstrings */
	node[] nh; /* Nachbarschaft von this */
	float[] nh_identifier;
	string[] nh_rs;

	/* Konstruktor */
	init() {
		identifier = h(id(this));
		rs = getBitstring(h1(id(this)));
	}
	
	/* Wird beim Initialisieren des Knotens aufgerufen */
	entry(node W) {
		W -> build(this);
	}
	
	/* Berechnet einen Bitstring der Länge RS_LENGTH anhand des Eingabewertes H */
	getBitstring string(float H) {
		string bitstring = "";
		int i;
		for (i = 0; i < RS_LENGTH; i++) {
			H = H * 2.0;
			if (H > 1) {
				bitstring = bitstring + 1;
				H = H - 1.0;
			}
			else if (H < 1) {
				bitstring = bitstring + 0;
			}
			else {
				bitstring = bitstring + 0;
				H = H / 2.0;
			}
		}
		return bitstring;
	}
	
	/* Gibt den Prefix der Länge I von V zurück */
	prefix string(string V, int I) {
		return sub_str(V, 0, I);
	}
	
	/* Ermittelt den größten gemeinsamen Prefix von V und W */
	commonPrefix int(string V, string W) {
		int i;
		for (i = RS_LENGTH; i > 0; i--) {
			if (prefix(V, i) == prefix(W, i)) {
				return i;
			}
		}
		return 0;
	}
	
	/* Ermittelt das aktuelle Level */
	level int() {
		int max = 0;
		for (node w : nh) {
			if (w != null) {
				int tmp = commonPrefix(rs, nh_rs[id(w)]);
				if (tmp > max) {
					max = tmp;
				}
			}
		}
		return max;
	}

	/* Hashfunktion h, bildet I auf [0,1) ab */
	h float(int I) {
		float i = hash(I);
		i = i / MAX_INTEGER;
		i = (i + 1) / 2;
		return i;
	}
	
	/* Hashfunktion h1, bildet I auf [0,1) ab. Wird genutzt um Bitstrings zu generieren. */
	h1 float(int I) {
		float i = hash1(I);
		i = i / MAX_INTEGER;
		i = (i + 1) / 2;
		return i;
	}
	
	/* Periodisches Timeout */
	timeout() {
		checkNeighbourhood();
		introduceNode();
		introduceClosestNeighbours();
		linearizeNeighbours();
	}
	
	/* Aktualisiert die Nachbarschaft; Entfernt ggf. w und delegiert an Knoten x mit größter Prefixübereinstimmung */
	checkNeighbourhood() {
		for (node w : nh) {
			if (w != null) {
				if (checkNode(w) == false) {
					nh[id(w)] = null;
					int argmax = 0;
					node max;
					for (node x : nh) {
						if (x != null) {
							int tmp = commonPrefix(nh_rs[id(w)], nh_rs[id(x)]);
							if (argmax <= tmp) {
								argmax = tmp;
								max = x;
							}
						}
					}
					nh_identifier[id(w)] = NaN;
					nh_rs[id(w)] = "";
					max -> build(w);
				}
			}
		}
	}
	
	/* Fügt X in nh ein */
	build(node X) {
		if (X == this | X == null) {
			return;
		}
		if (nh[id(X)] != null) {
			checkNeighbourhood();
		}
		else {
			nh[id(X)] = X;
			nh_identifier[id(X)] = h(id(X));
			nh_rs[id(X)] = getBitstring(h1(id(X)));
			if (checkNode(X) == true) {
				checkNeighbourhood();
			}
			else {
				nh[id(X)] = null;
				int argmax = 0;
				node max;
				for (node w : nh) {
					if (w != null) {
						int tmp = commonPrefix(nh_rs[id(X)], nh_rs[id(w)]);
						if (argmax <= tmp) {
							argmax = tmp;
							max = w;
						}
					}
				}
				nh_identifier[id(X)] = NaN;
				nh_rs[id(X)] = "";
				max -> build(X);
			}
		}
	}
	
	/* Prüft, ob ein Knoten W in der Range von this für eine Level i liegt */
	checkNode bool(node W) {
		bool needed = false;
		int i;
		for (i = 0; i <= level(); i++) {
			if (prefix(rs, i) == prefix(getBitstring(h1(id(W))), i)
				& (farthestPred(i) == null | nh_identifier[id(W)] >= nh_identifier[id(farthestPred(i))]) 
				& (farthestSucc(i) == null | nh_identifier[id(W)] <= nh_identifier[id(farthestSucc(i))])) {
				needed = true;
				break;
			}
		}
		return needed;
	}
	
	/* Ermittelt den entferntesten Vorgänger für ein Level I aus nh und einen Bit B */
	farthestPredB node(int I, string B) {
		node[] preds;
		predecessors(I, preds);
		node argmin;
		float min = 1.0;
		for (node u : preds) {
			if ((prefix(rs, I) + B) == prefix(nh_rs[id(u)], I + 1) & nh_identifier[id(u)] <= min) {
				argmin = u;
				min = nh_identifier[id(u)];
			}
		}
		preds <<<<;
		return argmin;
	}
	
	/* Ermittelt den entferntesten Vorgänger für ein Level I aus nh */
	farthestPred node(int I) {
		node pred0 = farthestPredB(I, "0");
		node pred1 = farthestPredB(I, "1");
		
		if (pred0 == null | pred1 == null) {
			return null;
		}
		
		if (nh_identifier[id(pred0)] < nh_identifier[id(pred1)]) {
			return pred0;
		}
		else {
			return pred1;
		}
	}
	
	/* Ermittelt den entferntesten Nachfolger für ein Level I aus nh und einen Bit B */
	farthestSuccB node(int I, string B) {
		node[] succs;
		successors(I, succs);
		node argmax;
		float max = 0.0;
		for (node u : succs) {
			if ((prefix(rs, I) + B) == prefix(nh_rs[id(u)], I + 1) & nh_identifier[id(u)] >= max) {
				argmax = u;
				max = nh_identifier[id(u)];
			}
		}
		succs <<<<;
		return argmax;
	}
	
	/* Ermittelt den entferntesten Nachfolger für ein Level I aus nh */
	farthestSucc node(int I) {
		node succ0 = farthestSuccB(I, "0");
		node succ1 = farthestSuccB(I, "1");
		
		if (succ0 == null | succ1 == null) {
			return null;
		}

		if (nh_identifier[id(succ0)] > nh_identifier[id(succ1)]) {
			return succ0;
		}
		else {
			return succ1;
		}
	}
	
	/* Sendet build-Anfragen an alle Nachbarknoten */
	introduceNode() {
		for (node w : nh) {
			if (w != null) {
				w -> build(this);
			}
		}
	}
	
	/* Stellt den Nachbarknoten die direkt Vorgänger und Nachfolger für jedes Level vor */
	introduceClosestNeighbours() {
		int i;
		for (i = 0; i <= level(); i++) {
			node[] list_neighbours;
			neighbours(i, list_neighbours);
			if (closestPred(i) != null) {
				for (node w : list_neighbours) {
					w -> build(closestPred(i));
				}
			}
			if (closestSucc(i) != null) {
				for (node w : list_neighbours) {
					w -> build(closestSucc(i));
				}
			}
		}
	}
	
	/* Linearisiere Nachbarknoten */
	linearizeNeighbours() {
		int i;
		for (i = 0; i <= level(); i++) {
			node[] preds;
			predecessors(i, preds);
			int j;
			for (j = 0; j < length(preds); j++) {
				node to = preds[j];
				node m = preds[j+1];
				to -> build(m);
			}
			preds <<<<;
			node[] succs;
			successors(i, succs);
			for (j = 0; j < length(succs); j++) {
				node to = succs[j];
				node m = succs[j+1];
				to -> build(m);
			}
			succs <<<<;
		}
	}
	
	/* Filtert alle Nachbarknoten für ein Level I in eine Liste C */
	neighbours(int I, node<> C) {
		C <<<<;
		for (node u : nh) {
			if (u != null) {
				if (commonPrefix(rs, nh_rs[id(u)]) == I) {
					C >> u;
				}
			}
		}
	}
	
	/* Filtert alle Vorgänger der Nachbarknoten für ein Level I in eine Liste A */
	predecessors(int I, node<> A) {
		A <<<<;
		neighbours(I, A);
		for (node u : A) {
			if (u != null) {
				if (nh_identifier[id(u)] < identifier) {
					A >> u;
					print("pred " + A[length(A)-1]);
				}
			}
		}

	}
	
	/* Gibt den nähesten Vorgänger für ein Level I zurück */
	closestPred node(int I) {
		node<> preds;
		preds <<<<;
		predecessors(I, preds);
		print("length preds " + length(preds));
		node argmax;
		float max = 0.0;
		for (node u : preds) {
			if (nh_identifier[id(u)] > max) {
				argmax = u;
				max = nh_identifier[id(u)];
			}
		}
		preds <<<<;
		return argmax;
	}
	
	/* Filtert alle Nachfolger der Nachbarknoten für ein Level I in eine Liste B */
	successors(int I, node<> B) {
		B <<<<;
		neighbours(I, B);
		for (node u : B) {
			if (nh_identifier[id(u)] > identifier) {
				B >> u;
				print("succ " + B[length(B)-1]);
			}
		}
	}
	
	/* Gibt den nähesten Nachfolger für ein Level I zurück */
	closestSucc node(int I) {
		node<> succs;
		succs <<<<;
		successors(I, succs);
		print("length succs " + length(succs));
		node argmin;
		float min = 1.0;
		for (node u : succs) {
			if (nh_identifier[id(u)] < min) {
				argmin = u;
				min = nh_identifier[id(u)];
			}
		}
		succs <<<<;
		return argmin;
	}
	
	/* Sendet eine Anfrage zum Verlassen des Netzwerks */
	leave() {
		for (node w : nh) {
			if (w != null) {
				w -> remove(this);
			}
		}
		nh <<<<;
		nh_identifier <<<<;
		nh_rs <<<<;
	}
	
	/* Entfernt einen Knoten X aus nh */
	remove(node X) {
		if (nh[id(X)] != null) {
			nh[id(X)] = null;
			nh_identifier[id(X)] = NaN;
			nh_rs[id(X)] = "";
		}
	}
	
	/* Stelle lookup-Anfrage an Knoten X */
	lookup(node X) {
		if (id(this) != id(X)) {
			string rs_x = getBitstring(h1(id(X)));
			int len;
			if (level() < commonPrefix(rs, rs_x)) {
				len = level();
			}
			else {
				len = commonPrefix(rs, rs_x);
			}
			
			node w = farthestPredB(len, sub_str(rs_x,len,len+1));
			if (w == null) {
				w = farthestSuccB(len, sub_str(rs_x,len,len+1));
			}
			w -> lookup(X);
		}
	}
}